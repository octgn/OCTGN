/* 
 * This file was automatically generated by Jesus!
 * Do not modify, or your sins will be regenerated!!
 * XML: "..\..\Octgn.Library\Scripting\GameEvents.xml"
 *
 * To create the .CS file for this document, 
 * right click the .tt file and click 'Run Custom Tool'
 */
<#@ template language="C#" hostspecific="true" #><#@ assembly name="System.Core" #><#@ assembly name="System.Xml" #><#@ assembly name="System.Xml.Linq" #><#@ import namespace="System.Linq" #><#@ import namespace="System.Xml.Linq" #><#@ import namespace="System.Collections.Generic" #><#@ import namespace="System.Text" #>
<#
    XDocument doc = XDocument.Load(Host.ResolvePath(@"..\..\Octgn.Library\Scripting\GameEvents.xml"));
#>
using System;
using System.Collections.Generic;
using Octgn.Play;
using log4net;

namespace Octgn.Scripting
{
	public class GameEventProxy
	{
		internal static ILog Log = LogManager.GetLogger(System.Reflection.MethodBase.GetCurrentMethod().DeclaringType);
		private readonly Engine engine;
		private readonly GameEngine gameEngine;
		private readonly Dictionary<string,Octgn.DataNew.Entities.GameEvent[]> eventCache;

		public bool MuteEvents {get;set;}
		public GameEventProxy(Engine scriptEngine, GameEngine gameEngine)
		{
			engine = scriptEngine;
			this.gameEngine = gameEngine;
			eventCache = new Dictionary<string,Octgn.DataNew.Entities.GameEvent[]>();
			<#
				foreach(var e in doc.Root.Descendants()
					.Where(x=>x.Name.LocalName == "event")
					.Select(x=>x.Attribute("name").Value).Distinct())
                {#>
			eventCache.Add("<#=e #>",new DataNew.Entities.GameEvent[0]);
			if(gameEngine.Definition.Events.ContainsKey("<#=e#>"))
				eventCache["<#=e #>"] = gameEngine.Definition.Events["<#=e #>"];
					<#
                }#>
		}
	<#
	foreach (var v in doc.Root.Elements().Where(x=>x.Name.LocalName == "eventversion"))
    {
		var versionString = v.Attribute("version").Value;
		var version = "_" + versionString.Replace(".","_");
		this.WriteLine("	private static readonly Version C" + version + " = Version.Parse(\"" + versionString + "\");");
    foreach (var eve in v.Elements().Where(x => x.Name.LocalName == "event"))
    {
		string bareEventName = eve.Attribute("name").Value;
        string eventName = bareEventName + version;
        PopIndent();
    #>
		public void <#= eventName #>(<#= ParametersList(eve, true) #>)
		{
			if(MuteEvents)return;
			if(gameEngine.Definition.ScriptVersion != <#= "C" + version #> )
				return;
			Log.Info("Firing event <#=  eventName #>");
			<#
			var paramArray = eve.Elements().Where(x => x.Name.LocalName == "param").ToArray();
			if (paramArray.Length > 0)
			{
				WriteLine("var args = new object[{0}];", paramArray.Length);
			}
			PushIndent("\t");
			PushIndent("\t");
			PushIndent("\t");
			for (var i = 0; i < paramArray.Length; i++)
			{
				WriteLine("args[{0}] = {1};", i, paramArray[i].Attribute("name").Value);
				//PopIndent();
			}
			var comma = paramArray.Length == 0 ?
				""
				: ",";
			PopIndent();
			PopIndent();
		  #>    
			foreach(var e in eventCache["<#= bareEventName #>"])
			{
				Log.InfoFormat("Firing event <#= eventName #> -> {0}",e.Name);
				engine.ExecuteFunction(e.PythonFunction<#= comma #><#= ParametersList(eve,false) #>);
			}<#
		PopIndent();
			#>
		}
<# } }#>
	}
}
<#+
    private string ParametersList(XElement eve, bool includeTypeNames)
    {
        var sb = new StringBuilder();
        foreach (var p in eve.Elements("{http://octgn.net/GameEvents.xsd}param"))
        {
            if (includeTypeNames)
            {
                sb.Append(
                    //ConvertParamType(
                        p.Attribute("type").Value
                    //)
                );
                sb.Append(" ");
            }
            sb.Append(p.Attribute("name").Value);
            sb.Append(", ");
        }
        if (sb.Length > 0) sb.Remove(sb.Length - 2, 2);
        return sb.ToString();
    }

    private string ConvertParamType(string type)
    {
        switch (type)
        {
            case "Player":
                return "byte";
            case "ControllableObject":
            case "Group":
            case "Card":
            case "Counter":
                return "int";
            case "Player[]":
                return "byte[]";
            case "Group[]":
                return "int[]";
            case "Color?":
                return "string";
            default:
                return type;
        }
    }

    private Dictionary<string, string> paramsOutput = new Dictionary<string, string>()
  {
    { "Version", "{0}.ToString()" },
    { "Guid", "{0}.ToString()" },
  
    { "Guid[]", @"{0}.Select(x=>x.ToString()).ToArray()" },

    { "CardOrientation", "{0}" },

    { "short[]", @"{0}" },

    { "int[]", @"{0}" },
    
    { "Player[]", @"{0}" },

    { "Group[]", @"{0}"},

    { "ulong[]", @"{0}" }
  };
#>