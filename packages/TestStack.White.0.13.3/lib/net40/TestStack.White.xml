<?xml version="1.0"?>
<doc>
    <assembly>
        <name>TestStack.White</name>
    </assembly>
    <members>
        <member name="T:TestStack.White.Application">
            <summary>
            Represents a process which contains windows.
            </summary>
        </member>
        <member name="M:TestStack.White.Application.Launch(System.String)">
            <summary>
            Runs the process identified by the executable and creates Application object for this executable
            </summary>
            <param name="executable">Path to the executable</param>
            <exception cref="T:System.ArgumentNullException">No process info passed</exception>
            <exception cref="T:TestStack.White.WhiteException">White Failed to Launch or Attached to process</exception>
        </member>
        <member name="M:TestStack.White.Application.Launch(System.Diagnostics.ProcessStartInfo)">
            <summary>
            Lauches the process and creates and Application object for it
            </summary>
            <exception cref="T:System.ArgumentNullException">No process info passed</exception>
            <exception cref="T:TestStack.White.WhiteException">White Failed to Launch or Attached to process</exception>
        </member>
        <member name="M:TestStack.White.Application.Attach(System.Int32)">
            <summary>
            Attaches White to an existing process by process id 
            </summary>
            <exception cref="T:TestStack.White.WhiteException">White Failed to Attach to process</exception>
        </member>
        <member name="M:TestStack.White.Application.Attach(System.Diagnostics.Process)">
            <summary>
            Attaches White to an existing process
            </summary>
            <exception cref="T:TestStack.White.WhiteException">White Failed to Attach to process</exception>
        </member>
        <member name="M:TestStack.White.Application.Attach(System.String)">
            <summary>
            Attaches with existing process
            </summary>
            <exception cref="T:TestStack.White.WhiteException">White Failed to Attach to process with specified name</exception>
        </member>
        <member name="M:TestStack.White.Application.AttachOrLaunch(System.Diagnostics.ProcessStartInfo)">
            <summary>
            Attaches to the process if it is running or launches a new process
            </summary>
            <param name="processStartInfo"></param>
            <returns></returns>
            <exception cref="T:System.ArgumentException"></exception>
            <exception cref="T:System.ArgumentNullException"></exception>
            <exception cref="T:TestStack.White.WhiteException">White Failed to Launch or Attach to process</exception>
        </member>
        <member name="M:TestStack.White.Application.GetWindow(System.String,TestStack.White.Factory.InitializeOption)">
            <summary>
            Get visible window
            </summary>
            <param name="title">Title text of window displayed on desktop</param>
            <param name="option">Option which would be used to initialize the window.</param>
            <returns></returns>
            <exception cref="T:TestStack.White.Factory.UIItemSearchException">The application type is not supported by White</exception>
        </member>
        <member name="M:TestStack.White.Application.GetWindow(System.String)">
            <summary>
            Get visible window. NoCache option is set by default
            </summary>
            <param name="title">Title text of window displayed on desktop</param>
            <returns></returns>
            <exception cref="T:TestStack.White.Factory.UIItemSearchException">The application type is not supported by White</exception>
        </member>
        <member name="M:TestStack.White.Application.GetWindow(TestStack.White.UIItems.Finders.SearchCriteria,TestStack.White.Factory.InitializeOption)">
            <summary>
            Find the first window which belongs to this application and satisfies the critera.
            </summary>
            <param name="searchCriteria"></param>
            <param name="initializeOption">found window would be initialized with this option</param>
            <returns></returns>
            <exception cref="T:TestStack.White.Factory.UIItemSearchException">The application type is not supported by White</exception>
        </member>
        <member name="M:TestStack.White.Application.Close">
            <summary>
            Tries to find the main window, then close it. If it hasn't closed in 5 seconds, kill the process
            </summary>
        </member>
        <member name="M:TestStack.White.Application.Kill">
            <summary>
            Kills the applications and waits till it is closed
            </summary>
        </member>
        <member name="M:TestStack.White.Application.GetWindows">
            <summary>
            All windows belonging to the application
            </summary>
            <returns></returns>
            <exception cref="T:TestStack.White.Factory.UIItemSearchException">The application type is not supported by White</exception>
        </member>
        <member name="M:TestStack.White.Application.Equals(System.Object)">
            <summary>
            Two applications are equal if they have the same process
            </summary>
            <param name="obj"></param>
            <returns></returns>
        </member>
        <member name="M:TestStack.White.Application.WaitWhileBusy">
            <summary>
            Waits till application is busy.
            </summary>
        </member>
        <member name="M:TestStack.White.Application.Find(System.Predicate{System.String},TestStack.White.Factory.InitializeOption)">
            <summary>
            Looks at all the windows visible for the application and finds one which matches the condition. The match is run against the title 
            of the windows
            </summary>
            <param name="match"></param>
            <param name="initializeOption">option for the window which matches the condition</param>
            <exception cref="T:TestStack.White.Factory.UIItemSearchException">The application type is not supported by White</exception>
        </member>
        <member name="M:TestStack.White.Application.KillAndSaveState">
            <summary>
            Kills the application. Read Application.Kill.
            It also saves the application test execution state. This saves the position of the window UIItems which would be loaded next time
            automatically for improved performance. You would need to use InitializedOption.AndIdentifiedBy for specifying the identification of window.
            </summary>
        </member>
        <member name="P:TestStack.White.Application.Name">
            <summary>
            Name of the process
            </summary>
        </member>
        <member name="P:TestStack.White.Application.ApplicationSession">
            <summary>
            Internal to white
            </summary>
        </member>
        <member name="P:TestStack.White.Application.HasExited">
            <summary>
            Returns whether process has exited
            </summary>
        </member>
        <member name="T:TestStack.White.Bricks.DelegateInvoker">
            <summary>
            This class builds an object to invoke a late-bound method, without using MethodInfo.InvokeAction and thus avoiding exceptions being wrapped 
            as target invocation exceptions.
            </summary>
        </member>
        <member name="T:TestStack.White.Configuration.ConfigurationExtensions">
            <summary>
            Used to ensure backwards compatibility
            </summary>
        </member>
        <member name="M:TestStack.White.InputDevices.Input64.#ctor(TestStack.White.WindowsAPI.Input)">
            <summary>
            Converts a 32bit Input to a 64bit Input
            </summary>
            <param name="input"></param>
        </member>
        <member name="F:TestStack.White.InputDevices.SystemMetric.SM_SWAPBUTTON">
            <summary>
            Nonzero if the meanings of the left and right mouse buttons are swapped; otherwise, 0.
            </summary>
        </member>
        <member name="T:TestStack.White.AutomationElementSearch.AutomationElementFinder">
            <summary>
            Internal to white and should not be used unless a known issue. One should be able to find all items 
            </summary>
        </member>
        <member name="M:TestStack.White.AutomationElementSearch.AutomationElementFinder.FindDescendantRaw(TestStack.White.AutomationElementSearch.AutomationSearchCondition)">
            <summary>
            Uses the Raw View provided by UIAutomation to find elements. RawView sometimes contains extra AutomationElements. This is internal to 
            white although made public. Should be used only if the standard approaches dont work. Also if you end up using it please raise an issue
            so that it can be fixed
            Please understand that calling this method on any UIItem which has a lot of child AutomationElements might result in very bad performance.
            </summary>
            <param name="automationSearchCondition"></param>
            <returns>null or found AutomationElement</returns>
        </member>
        <member name="P:TestStack.White.AutomationException.DebugDetails">
            <summary>
            Contains the current UI Automation tree
            </summary>
        </member>
        <member name="T:TestStack.White.Configuration.ICoreConfiguration">
            <summary>
            Represents all the configuration at Core level. These configuration can be set from the configuration file as well as programmatically.
            </summary>
        </member>
        <member name="P:TestStack.White.Configuration.ICoreConfiguration.BusyTimeout">
            <summary>
            In Milliseconds
            </summary>
        </member>
        <member name="M:TestStack.White.Configuration.IWaitHook.WaitFor(TestStack.White.UIItems.UIItemContainer)">
            <summary>
            This callback would be provided whenever any action is performed using white. This is additional callback apart from regular waits based on window/process being busy.
            This provides additional oppurtunity to wait based application specific condition.
            </summary>
            <param name="uiItemContainer">Container in which action was performed, this applies only if the container explicity handles wait. 
            This is also called for window which handles wait. Other than window only SilverlightDocument handles the wait.
            In silverlight one would receive two callbacks one with window and other with SilverlightDocument</param>
        </member>
        <member name="M:TestStack.White.UIItems.IUIItem.ErrorProviderMessage(TestStack.White.UIItems.WindowItems.Window)">
            <summary>
            Provides the Error on this UIItem. This would return Error object when this item has ErrorProvider displayed next to it.
            </summary>
            <param name="window"></param>
            <returns></returns>
        </member>
        <member name="M:TestStack.White.UIItems.IUIItem.Click">
            <summary>
            Performs mouse click at the center of this item
            </summary>
        </member>
        <member name="M:TestStack.White.UIItems.IUIItem.DoubleClick">
            <summary>
            Performs mouse double click at the center of this item
            </summary>
        </member>
        <member name="M:TestStack.White.UIItems.IUIItem.KeyIn(TestStack.White.WindowsAPI.KeyboardInput.SpecialKeys)">
            <summary>
            Perform keyboard action on this UIItem
            </summary>
            <param name="key"></param>
        </member>
        <member name="M:TestStack.White.UIItems.IUIItem.UnHookEvents">
            <summary>
            Internal to white and intended to be used for white recording
            </summary>
        </member>
        <member name="M:TestStack.White.UIItems.IUIItem.HookEvents(TestStack.White.Recording.UIItemEventListener)">
            <summary>
            Internal to white and intended to be used for white recording
            </summary>
            <param name="eventListener"></param>
        </member>
        <member name="M:TestStack.White.UIItems.IUIItem.GetElement(TestStack.White.UIItems.Finders.SearchCriteria)">
            <summary>
            Uses the Raw View provided by UIAutomation to find elements within this UIItem. RawView sometimes contains extra AutomationElements. This is internal to 
            white although made public. Should be used only if the standard approaches dont work. Also if you end up using it please raise an issue
            so that it can be fixed.
            Please understand that calling this method on any UIItem which has a lot of child AutomationElements might result in very bad performance.
            </summary>
            <param name="searchCriteria"></param>
            <returns>null or found AutomationElement</returns>
        </member>
        <member name="P:TestStack.White.UIItems.IUIItem.AutomationElement">
            <summary>
            Should be used only if white doesn't support the feature you are looking for.
            Knowledge of UIAutomation would be required. It would better idea to also raise an issue if you are using it.
            </summary>
        </member>
        <member name="M:TestStack.White.UIItems.UIItem.ErrorProviderMessage(TestStack.White.UIItems.WindowItems.Window)">
            <summary>
            Provides the Error on this UIItem. This would return Error object when this item has ErrorProvider displayed next to it.
            </summary>
            <param name="window"></param>
            <returns></returns>
        </member>
        <member name="M:TestStack.White.UIItems.UIItem.Click">
            <summary>
            Performs mouse click at the center of this item
            </summary>
        </member>
        <member name="M:TestStack.White.UIItems.UIItem.DoubleClick">
            <summary>
            Performs mouse double click at the center of this item
            </summary>
        </member>
        <member name="M:TestStack.White.UIItems.UIItem.KeyIn(TestStack.White.WindowsAPI.KeyboardInput.SpecialKeys)">
            <summary>
            Perform keyboard action on this UIItem
            </summary>
            <param name="key"></param>
        </member>
        <member name="M:TestStack.White.UIItems.UIItem.UnHookEvents">
            <summary>
            Internal to white and intended to be used for white recording
            </summary>
        </member>
        <member name="M:TestStack.White.UIItems.UIItem.HookEvents(TestStack.White.Recording.UIItemEventListener)">
            <summary>
            Internal to white and intended to be used for white recording
            </summary>
            <param name="eventListener"></param>
        </member>
        <member name="M:TestStack.White.UIItems.UIItem.GetElement(TestStack.White.UIItems.Finders.SearchCriteria)">
            <summary>
            Uses the Raw View provided by UIAutomation to find elements within this UIItem. RawView sometimes contains extra AutomationElements. This is internal to 
            white although made public. Should be used only if the standard approaches dont work. Also if you end up using it please raise an issue
            so that it can be fixed.
            Please understand that calling this method on any UIItem which has a lot of child AutomationElements might result in very bad performance.
            </summary>
            <param name="searchCriteria"></param>
            <returns>null or found AutomationElement</returns>
        </member>
        <member name="M:TestStack.White.UIItems.UIItem.DrawHighlight">
            <summary>
            Highlight UIItem with red frame
            </summary>
        </member>
        <member name="P:TestStack.White.UIItems.UIItem.AutomationElement">
            <summary>
            Should be used only if white doesn't support the feature you are looking for.
            Knowledge of UIAutomation would be required. It would better idea to also raise an issue if you are using it.
            </summary>
        </member>
        <member name="M:TestStack.White.UIItems.IUIItemContainer.Get``1">
            <summary>
            Finds UIItem which matches specified type. Useful for non managed applications where controls are not identified by AutomationId, like in 
            Managed applications. In case of multiple items of this type the first one found would be returned which cannot be guaranteed to be the same 
            across multiple invocations.
            </summary>
            <typeparam name="T">IUIItem type e.g. Button, TextBox</typeparam>
            <returns>First item of supplied type</returns>
            <exception cref="T:TestStack.White.AutomationException">when item not found</exception>
            <exception cref="T:TestStack.White.WhiteException">when any errors occured during search</exception>
        </member>
        <member name="M:TestStack.White.UIItems.IUIItemContainer.Get``1(System.String)">
            <summary>
            Finds UIItem which matches specified type and identification. 
            In case of multiple items of this type the first one found would be returned which cannot be guaranteed to be the same across multiple 
            invocations. For managed applications this is name given to controls in the application code.
            For unmanaged applications this is text of the control or label next to it if it doesn't have well defined text.
            <!--e.g. TextBox doesn't have any predefined text of its own as it can be changed at runtime by user, hence is identified by the label next to it.
            If there is no label then Get<T> or Get<T>(SearchCriteria) method can be used.-->
            </summary>
            <typeparam name="T">IUIItem implementation</typeparam>
            <param name="primaryIdentification">For managed application this is the name provided in application code and unmanaged application this is 
            the text or label next to it based identification</param>
            <returns>First item of supplied type and identification</returns>
            <exception cref="T:TestStack.White.AutomationException">when item not found</exception>
            <exception cref="T:TestStack.White.WhiteException">when any errors occured during search</exception>
        </member>
        <member name="M:TestStack.White.UIItems.IUIItemContainer.Get``1(TestStack.White.UIItems.Finders.SearchCriteria)">
            <summary>
            Finds UIItem which matches specified type and searchCriteria. Type supplied need not be supplied again in SearchCondition.
            <!--e.g. in Get<Button>(SearchCriteria.ByAutomationId("OK").ByControlType(typeof(Button)).Indexed(1) the ByControlType(typeof(Button)) part 
            is redundant. Look at documentation of SearchCriteria for details on it.-->
            </summary>
            <code>
            </code>
            <typeparam name="T"></typeparam>
            <param name="searchCriteria">Criteria provided to search UIItem</param>
            <returns>First items matching the type and criteria</returns>
            <exception cref="T:TestStack.White.AutomationException">when item not found</exception>
            <exception cref="T:TestStack.White.WhiteException">when any errors occured during search</exception>
        </member>
        <member name="M:TestStack.White.UIItems.IUIItemContainer.Get(TestStack.White.UIItems.Finders.SearchCriteria)">
            <summary>
            Finds UIItem which matches specified type and searchCriteria using the default BusyTimeout. Look at documentation of SearchCriteria for details on it.
            </summary>
            <param name="searchCriteria">Criteria provided to search IUIItem</param>
            <returns>First items matching the criteria</returns>
            <exception cref="T:TestStack.White.AutomationException">when item not found</exception>
            <exception cref="T:TestStack.White.WhiteException">when any errors occured during search</exception>
        </member>
        <member name="M:TestStack.White.UIItems.UIItemContainer.Get(TestStack.White.UIItems.Finders.SearchCriteria,System.TimeSpan)">
            <summary>
            Finds UIItem which matches specified type and searchCriteria. Look at documentation of SearchCriteria for details on it.
            </summary>
            <param name="searchCriteria">Criteria provided to search IUIItem</param>
            <param name="timeout">Time to wait for item to come on-screen before returning off-screen element, if found.</param>
            <returns>First items matching the criteria</returns>
            <exception cref="T:TestStack.White.AutomationException">when item not found</exception>
            <exception cref="T:TestStack.White.WhiteException">when any errors occured during search</exception>
        </member>
        <member name="M:TestStack.White.UIItems.UIItemContainer.ReInitialize(TestStack.White.Factory.InitializeOption)">
            <summary>
            Applicable only if CacheMode is used. This is for internal purpose of white and should not be used, as caching by itself is not supported
            </summary>
            <param name="option"></param>
        </member>
        <member name="M:TestStack.White.UIItems.UIItemContainer.ItemsWithin(TestStack.White.UIItems.UIItem)">
            <summary>
            Find all the UIItems which belongs to a window and are within (bounds of) another UIItem.
            </summary>
            <param name="containingItem">Containing item</param>
            <returns>List of all the items.</returns>
        </member>
        <member name="P:TestStack.White.UIItems.UIItemContainer.Items">
            <summary>
            Returns a list of UIItems contained in the container/window. This is not the same as AutomationElements because white needs to translate
            AutomationElements to UIItem. Hence for certain AE there might not be corresponding UIItem type.
            </summary>
        </member>
        <member name="P:TestStack.White.UIItems.UIItemContainer.Keyboard">
            <summary>
            Returns a keyboard which is associated to this window. Any operation performed using the mouse would wait till the window is busy after this
            operation. Before any operation is performed the window is brought to focus.
            </summary>
        </member>
        <member name="P:TestStack.White.UIItems.UIItemContainer.Mouse">
            <summary>
            Returns a mouse which is associated to this window. Any operation performed using the mouse would wait till the window is busy after this
            operation. Before any operation is performed the window is brought to focus.
            </summary>
        </member>
        <member name="M:TestStack.White.Desktop.CaptureScreenshot">
            <summary>
            Captures a screenshot of the entire desktop, and returns the bitmap
            </summary>
        </member>
        <member name="M:TestStack.White.Desktop.TakeScreenshot(System.String,System.Drawing.Imaging.ImageFormat)">
            <summary>
            Takes a screenshot of the entire desktop, and saves it to disk
            </summary>
            <param name="filename">The fullname of the file (including extension)</param>
            <param name="imageFormat"></param>
        </member>
        <member name="M:TestStack.White.Factory.ChildWindowFactory.Create(System.Windows.Automation.AutomationElement,TestStack.White.Factory.InitializeOption,TestStack.White.Sessions.WindowSession)">
            <exception cref="T:TestStack.White.Factory.UIItemSearchException">The application type is not supported by White</exception>
        </member>
        <member name="M:TestStack.White.Factory.WindowFactory.CreateWindow(System.String,System.Diagnostics.Process,TestStack.White.Factory.InitializeOption,TestStack.White.Sessions.WindowSession)">
            <exception cref="T:TestStack.White.Factory.UIItemSearchException">The application type is not supported by White</exception>
        </member>
        <member name="M:TestStack.White.Factory.WindowFactory.CreateWindow(TestStack.White.UIItems.Finders.SearchCriteria,System.Diagnostics.Process,TestStack.White.Factory.InitializeOption,TestStack.White.Sessions.WindowSession)">
            <exception cref="T:TestStack.White.Factory.UIItemSearchException">The application type is not supported by White</exception>
        </member>
        <member name="M:TestStack.White.Factory.WindowFactory.FindWindow(System.Diagnostics.Process,System.Predicate{System.String},TestStack.White.Factory.InitializeOption,TestStack.White.Sessions.WindowSession)">
            <exception cref="T:TestStack.White.Factory.UIItemSearchException">The application type is not supported by White</exception>
        </member>
        <member name="M:TestStack.White.Factory.WindowFactory.FindModalWindow(System.String,System.Diagnostics.Process,TestStack.White.Factory.InitializeOption,System.Windows.Automation.AutomationElement,TestStack.White.Sessions.WindowSession)">
            <exception cref="T:TestStack.White.Factory.UIItemSearchException">The application type is not supported by White</exception>
        </member>
        <member name="M:TestStack.White.Factory.WindowFactory.FindModalWindow(TestStack.White.UIItems.Finders.SearchCriteria,TestStack.White.Factory.InitializeOption,System.Windows.Automation.AutomationElement,TestStack.White.Sessions.WindowSession)">
            <exception cref="T:TestStack.White.Factory.UIItemSearchException">The application type is not supported by White</exception>
        </member>
        <member name="M:TestStack.White.Factory.WindowFactory.DesktopWindows">
            <exception cref="T:TestStack.White.Factory.UIItemSearchException">The application type is not supported by White</exception>
        </member>
        <member name="T:TestStack.White.Factory.InitializeOption">
            <summary>
            In cache mode:
            The return window contains all primary controls. Is useful when you are going to perform lot of actions on a window.
            Caching of controls is done only at this call. The cache is not refreshed automatically.
            In non-cache mode:
            The controls would be found based on demand. 
            </summary>
        </member>
        <member name="M:TestStack.White.Factory.InitializeOption.AndIdentifiedBy(System.String)">
            <summary>
            Specify the unique identification for your window. White remembers the location of UIItems inside a window as you find them.
            Next time when items inside the same window is found they are located first based on position which is faster.
            </summary>
            <param name="identifier"></param>
            <returns></returns>
        </member>
        <member name="P:TestStack.White.Factory.InitializeOption.WithCache">
            <summary>
            This option should not be used as this is only for internal white purposes
            </summary>
        </member>
        <member name="T:TestStack.White.InputDevices.AttachedKeyboard">
            <summary>
            Any operation performed using the keyboard would wait till the container is busy after this operation. Before any operation is 
            performed on the container, from which it was retreived, is brought to focus if it is not.
            </summary>
        </member>
        <member name="T:TestStack.White.InputDevices.AttachedMouse">
            <summary>
            Any operation performed using the mouse would wait till the window is busy after this operation. Before any operation is 
            performed the window, from which it was retreived, is brought to focus if it is not.
            </summary>
        </member>
        <member name="T:TestStack.White.InputDevices.Keyboard">
            <summary>
            Represents Keyboard attachment to the machine.
            </summary>
        </member>
        <member name="F:TestStack.White.InputDevices.Keyboard.Instance">
            <summary>
            Use Window.Keyboard method to get handle to the Keyboard. Keyboard instance got using this method would not wait while the application
            is busy.
            </summary>
        </member>
        <member name="M:TestStack.White.InputDevices.Mouse.DragAndDrop(TestStack.White.UIItems.IUIItem,TestStack.White.UIItems.IUIItem)">
            <summary>
            Drags the dragged item and drops it on the drop item. This can be used for any two UIItems
            whether they are same application or different. To drop items on desktop use Desktop 
            class's Drop method. White starts and ends the drag from center of the UIItems.
            Some drag and drop operation need to wait for application to process something while item is being dragged.
            This can be set but configuring DragStepCount property. This is by default set to 1.
            </summary>
            <param name="draggedItem"></param>
            <param name="dropItem"></param>
        </member>
        <member name="M:TestStack.White.InputDevices.Mouse.DragAndDrop(TestStack.White.UIItems.IUIItem,System.Windows.Point,TestStack.White.UIItems.IUIItem,System.Windows.Point)">
            <summary>
            Drags the dragged item and drops it on the drop item. This can be used for any two UIItems
            whether they are same application or different. To drop items on desktop use Desktop 
            class's Drop method. White starts and ends the drag from center of the UIItems.
            Some drag and drop operation need to wait for application to process something while item is being dragged.
            This can be set but configuring DragStepCount property. This is by default set to 1.
            </summary>
            <param name="draggedItem"></param>
            <param name="startPosition">Start point of the drag. You can do uiItem.Bounds to get bounds of the UIItem and use RectX extension class in White.Core.UIA namespace to find different points</param>
            <param name="dropItem"></param>
            <param name="endPosition">End point of the drag. You can do uiItem.Bounds to get bounds of the UIItem and use RectX extension class in White.Core.UIA namespace to find different points</param>
        </member>
        <member name="T:TestStack.White.ScreenCapture">
            <summary>
            Provides functions to capture the entire screen, or a particular window, and save it to a file.
            </summary>
        </member>
        <member name="M:TestStack.White.UIItems.Finders.SearchConditionFactory.CreateForFrameworkId(System.String)">
            <summary>
            
            </summary>
            <param name="frameworkId">List available from WindowsFramework class or Constants class</param>
            <returns></returns>
        </member>
        <member name="T:TestStack.White.UIItems.ListBoxItems.ListControl">
            <summary>
            ListControl is made of up ListItems and scroll bars.
            </summary>
        </member>
        <member name="M:TestStack.White.UIItems.ListBoxItems.ListControl.Select(System.String)">
            <summary>
            Selects list item which matches the text.
            (For WPF application the lists of objects might require you to provide a ToString override to be selected by text.
            The standard ToString method returns the objects type so all objects of the same type will look alike.)
            </summary>
            <param name="itemText"></param>
        </member>
        <member name="M:TestStack.White.UIItems.ListBoxItems.ListControl.Select(System.Int32)">
            <summary>
            Selects list item by its index
            </summary>
            <param name="index"></param>
        </member>
        <member name="P:TestStack.White.UIItems.ListBoxItems.ListControl.Items">
            <summary>
            Returns all the items belonging to the ListControl
            </summary>
        </member>
        <member name="P:TestStack.White.UIItems.ListBoxItems.WinFormComboBox.Text">
            <summary>
            Set the text in the TextBox inside the combobox.
            </summary>
        </member>
        <member name="M:TestStack.White.UIItems.PropertyGridItems.PropertyGrid.Category(System.String)">
            <summary>
            Find a category
            </summary>
            <param name="name"></param>
            <returns>PropertyGridCategory matching the name</returns>
        </member>
        <member name="P:TestStack.White.UIItems.PropertyGridItems.PropertyGrid.Categories">
            <summary>
            Provides a list of categories in the property grid.
            </summary>
        </member>
        <member name="M:TestStack.White.UIItems.Slider.Increment">
            <summary>
            Increments the slider
            </summary>
        </member>
        <member name="M:TestStack.White.UIItems.Slider.Increment(System.Double)">
            <summary>
            Increments the slider to the specified position
            </summary>
            <param name="to">New position</param>
            <exception cref="T:System.ArgumentOutOfRangeException">When <paramref name="to"/> is greater than the maximum value supported</exception>
            <exception cref="T:System.InvalidOperationException">When <paramref name="to"/> is less than the current value</exception>
        </member>
        <member name="M:TestStack.White.UIItems.Slider.Decrement">
            <summary>
            Decrements the slider
            </summary>
        </member>
        <member name="M:TestStack.White.UIItems.Slider.Decrement(System.Double)">
            <summary>
            Decrements the slider to the specified position
            </summary>
            <param name="to">New position</param>
            <exception cref="T:System.ArgumentOutOfRangeException">When <paramref name="to"/> is less than the minimum value supported</exception>
            <exception cref="T:System.InvalidOperationException">When <paramref name="to"/> is greater than the current value</exception>
        </member>
        <member name="T:TestStack.White.UIItems.DateFormat">
            <summary>
            Format in which the data in entered in the DateTimePicker. e.g. DayMonthYear, DayYearMonth, etc.
            </summary>
        </member>
        <member name="M:TestStack.White.UIItems.DateFormat.Parse(System.String)">
            <summary>
            Use ',' as separator.
            </summary>
        </member>
        <member name="M:TestStack.White.UIItems.Thumb.SlideHorizontally(System.Int32)">
            <summary>
            Move horizontally
            </summary>
            <param name="distance">postive value for increasing X, negative for lesser X</param>
        </member>
        <member name="M:TestStack.White.UIItems.Thumb.SlideVertically(System.Int32)">
            <summary>
            Move vertically
            </summary>
            <param name="distance">postive value downwards, negative for upwards</param>
        </member>
        <member name="F:TestStack.White.UIItems.WindowItems.Window.minOpenTime">
            <summary>
            If a window is opened then you try and close it straight away, the window can fail to close
            
            This make sure the window is open for a minimum amount of time
            </summary>
        </member>
        <member name="M:TestStack.White.UIItems.WindowItems.Window.WaitForWindow">
            <exception cref="T:System.Exception"></exception>
            <exception cref="T:TestStack.White.UIItems.UIActionException">when window is not responding</exception>
        </member>
        <member name="M:TestStack.White.UIItems.WindowItems.Window.WaitForProcess">
            <exception cref="T:System.ArgumentException">when current process is not available any more (id expired)</exception>
        </member>
        <member name="M:TestStack.White.UIItems.WindowItems.Window.ModalWindow(System.String,TestStack.White.Factory.InitializeOption)">
            <summary>
            Get the modal window launched by this window.
            </summary>
            <param name="title">Title of the modal window</param>
            <param name="option">Newly created window would be initialized using this option</param>
            <returns></returns>
        </member>
        <member name="M:TestStack.White.UIItems.WindowItems.Window.ModalWindow(System.String)">
            <summary>
            Get the modal window launched by this window and it uses InitializeOption as NoCache
            </summary>
            <param name="title">Title of the modal window</param>
            <returns></returns>
        </member>
        <member name="M:TestStack.White.UIItems.WindowItems.Window.ModalWindow(TestStack.White.UIItems.Finders.SearchCriteria,TestStack.White.Factory.InitializeOption)">
            <summary>
            Get the modal window launched by this window.
            </summary>
            <param name="searchCriteria">Search Criteria to use to find a window</param>
            <param name="option">Newly created window would be initialized using this option</param>
            <returns></returns>
        </member>
        <member name="M:TestStack.White.UIItems.WindowItems.Window.ModalWindow(TestStack.White.UIItems.Finders.SearchCriteria)">
            <summary>
            Get the modal window launched by this window with NoCache initialize option
            </summary>
            <param name="searchCriteria">Search Criteria to use to find a window</param>
            <returns></returns>
        </member>
        <member name="M:TestStack.White.UIItems.WindowItems.Window.WaitTill(TestStack.White.UIItems.WindowItems.Window.WaitTillDelegate)">
            <summary>
            Execute WaitTill with the default timeout from CoreConfiguration (BusyTimeout)
            </summary>
            <exception cref="T:TestStack.White.UIItems.UIActionException">when methods reached the timeout</exception>
        </member>
        <member name="M:TestStack.White.UIItems.WindowItems.Window.WaitTill(TestStack.White.UIItems.WindowItems.Window.WaitTillDelegate,System.TimeSpan)">
            <exception cref="T:TestStack.White.UIItems.UIActionException">when methods reached the timeout</exception>
        </member>
        <member name="M:TestStack.White.UIItems.WindowItems.Window.MessageBox(System.String)">
            <summary>
            Get the MessageBox window launched by this window
            </summary>
            <param name="title">Title of the messagebox</param>
            <returns></returns>
        </member>
        <member name="M:TestStack.White.UIItems.WindowItems.Window.MdiChild(TestStack.White.UIItems.Finders.SearchCriteria)">
            <summary>
            Returns a UIItemContainer using which other sub-ui items can be retrieved.
            Since there is no single standard identification for MdiChild windows, hence it is has been left open for user.
            </summary>
            <param name="searchCriteria"></param>
            <returns></returns>
        </member>
        <member name="M:TestStack.White.UIItems.WindowItems.Window.ModalWindows">
            <summary>
            Recursively gets all the descendant windows.
            </summary>
            <returns></returns>
            <exception cref="T:TestStack.White.Factory.UIItemSearchException">The application type is not supported by White</exception> // from ChildWindowFactory.Create
        </member>
        <member name="M:TestStack.White.UIItems.WindowItems.Window.PopupMenu(System.String[])">
            <summary>
            This should be used after RightClick on a UIItem (which can be window as well).
            </summary>
            <param name="path">Path to the menu which need to be retrieved.
            e.g. "Root" is one of the menus in the first level, "Level1" is inside "Root" menu and "Level2" is inside "Level1". So on.
            "Root", etc are text of the menu visible to user.
            </param>
            <returns></returns>
        </member>
        <member name="P:TestStack.White.UIItems.WindowItems.Window.IsClosed">
            <summary>
            Returns true if window available and is on screen. Otherwise 
            or if there were errors it returns false.
            </summary>
        </member>
        <member name="P:TestStack.White.UIItems.WindowItems.Window.IsCurrentlyActive">
            <summary>
            Tells whether the window is currently the topmost window. CAUTION: For Non-WPF applications it might perform poorly if there are a lot of controls
            in the window.
            </summary>
            <returns>true if topmost</returns>
        </member>
        <member name="T:TestStack.White.UIItems.Panel">
            <summary>
            Represents ControlType.Pane object. Child UIItems can be found from it.
            </summary>
        </member>
        <member name="P:TestStack.White.UIItems.TextBox.Text">
            <summary>
            Enters the text in the textbox. The text would be cleared first. This is not as good performing as the BulkText method. 
            This does raise all keyboard events - that means that your string will consist of letters that match the letters
            of your string but in current input language.
            </summary>
        </member>
        <member name="P:TestStack.White.UIItems.TextBox.BulkText">
            <summary>
            Sets the text in the textbox. The text would be cleared first. This is a better performing than the Text method. This doesn't raise all keyboard events.
            The string will be set exactly as it is in your code.
            </summary>
        </member>
        <member name="M:TestStack.White.Utility.Retry.ForDefault(System.Func{TestStack.White.UIItems.WindowItems.Window})">
            <summary>
            Retries until method returns a non-default value using default timeout for window
            </summary>
            <param name="getMethod">The operation to perform.</param>
        </member>
        <member name="M:TestStack.White.Utility.Retry.ForDefault(System.Func{TestStack.White.UIItems.WindowItems.Window},System.Predicate{TestStack.White.UIItems.WindowItems.Window})">
            <summary>
            Retries as long as predicate is satisfied using default timeout for window
            </summary>
            <param name="getMethod">The operation to perform.</param>
            <param name="shouldRetry">The predicate used for retry.</param>
        </member>
        <member name="M:TestStack.White.Utility.Retry.ForDefault``1(System.Func{``0})">
            <summary>
            Retries until method returns a non-default value using default element timeout
            </summary>
            <param name="getMethod">The operation to perform.</param>
        </member>
        <member name="M:TestStack.White.Utility.Retry.ForDefault``1(System.Func{``0},System.Predicate{``0})">
            <summary>
            Retries as long as predicate is satisfied using default element timeout
            </summary>
            <param name="getMethod">The operation to perform.</param>
            <param name="shouldRetry">The predicate used for retry.</param>
        </member>
        <member name="M:TestStack.White.Utility.Retry.For(System.Action,System.TimeSpan)">
            <summary>
            Retries until action does not throw an exception
            </summary>
            <param name="action">The operation to perform.</param>
            <param name="retryFor">The duration before timing outs.</param>
        </member>
        <member name="M:TestStack.White.Utility.Retry.For(System.Func{System.Boolean},System.TimeSpan,System.Nullable{System.TimeSpan})">
            <summary>
            Retries until method returns true
            </summary>
            <param name="getMethod">The operation to perform.</param>
            <param name="retryFor">The duration before timing out.</param>
            <param name="retryInterval">The time to sleep betwen retries.</param>
        </member>
        <member name="M:TestStack.White.Utility.Retry.For``1(System.Func{``0},System.TimeSpan,System.Nullable{System.TimeSpan})">
            <summary>
            Retries until method returns a non-default value
            </summary>
            <param name="getMethod">The operation to perform.</param>
            <param name="retryFor">The duration before timing out.</param>
            <param name="retryInterval">The time to sleep betwen retries.</param>
        </member>
        <member name="M:TestStack.White.Utility.Retry.For``1(System.Func{``0},System.Predicate{``0},System.TimeSpan,System.Nullable{System.TimeSpan})">
            <summary>
            Retries as long as predicate is satisfied
            </summary>
            <param name="getMethod">The operation to perform.</param>
            <param name="shouldRetry">The predicate used for retry.</param>
            <param name="retryFor">The duration before timing out.</param>
            <param name="retryInterval">The time to sleep betwen retries.</param>
        </member>
        <member name="T:TestStack.White.WindowsAPI.WindowPlacement">
            <summary>
            Intended for White Internal use only
            </summary>
        </member>
        <member name="T:TestStack.White.WindowsAPI.WindowInfo">
            <summary>
            Intended for White Internal use only
            </summary>
        </member>
        <member name="T:TestStack.White.WindowsAPI.MouseInput">
            <summary>
            Intended for White Internal use only
            </summary>
        </member>
        <member name="T:TestStack.White.WindowsAPI.KeyboardInput">
            <summary>
            Intended for White Internal use only
            </summary>
        </member>
        <member name="T:TestStack.White.WindowsAPI.HardwareInput">
            <summary>
            Intended for White Internal use only
            </summary>
        </member>
        <member name="T:TestStack.White.WindowsAPI.CursorInfo">
            <summary>
            Intended for White Internal use only
            </summary>
        </member>
        <member name="T:TestStack.White.WindowsAPI.POINT">
            <summary>
            Intended for White Internal use only
            </summary>
        </member>
        <member name="T:TestStack.White.WindowsAPI.COLORREF">
            <summary>
            Intended for White Internal use only
            </summary>
        </member>
        <member name="T:TestStack.White.InputDevices.WindowsConstants">
            <summary>
            Constants defined in winuser.h in C:\Program Files\Microsoft Visual Studio 8\VC\PlatformSDK\Include\WinUser.h
            </summary>
        </member>
        <member name="M:TestStack.White.UIItems.CheckBox.UnSelect">
            <summary>
            Unchecks the checkbox
            </summary>
        </member>
        <member name="P:TestStack.White.UIItems.CheckBox.IsSelected">
            <summary>
            true when CheckBox is checked
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "P:TestStack.White.UIItems.Custom.CustomUIItem.Container" -->
        <member name="T:TestStack.White.UIItems.Finders.SearchCriteria">
            <summary>
            SearchCritera can be used when UIItem identification is not satisfied by standard Get methods on UIItemContainer (Window is subclass of 
            UIItemContainer). Multiple criterias can be supplied together based on which the UIItem would be searched. All the conditions would put together as
            AND condition
            e.g. SearchCriteria.ByAutomationId("foo").ByControlType(typeof(TextBox)).Indexed(1)
            </summary>
        </member>
        <member name="M:TestStack.White.UIItems.Finders.SearchCriteria.ByText(System.String)">
            <summary>
            Create a SearchCriteria with text
            </summary>
            <param name="text">For managed applications this is name given to controls in the application code. 
            For unmanaged applications this is text of the control or label next to it if it doesn't have well defined text.</param>
            <returns></returns>
        </member>
        <member name="M:TestStack.White.UIItems.Finders.SearchCriteria.Indexed(System.Int32)">
            <summary>
            Create criteria with specified index
            </summary>
            <param name="zeroBasedIndex"></param>
            <returns></returns>
        </member>
        <member name="M:TestStack.White.UIItems.ListBoxItems.ListItem.WaitForBoundsToStabilise(TestStack.White.UIItems.IUIItem)">
            <summary>
            When the dropdown is animating, this can stop White from clicking too soon and not selecting properly
            </summary>
            <param name="item"></param>
        </member>
        <member name="T:TestStack.White.UIItems.ListView">
            <summary>
            Understands testing ListView in WinForm and WPF. Anything which is of ControlType=DataGrid. In order to test DataGridView in WinForm use
            Table class.
            A ListView consists of ListViewHeader and ListViewRows. ListViewHeader contains ListViewColumns. ListViewRows is collection of all the visible
            rows. A ListViewRow consists of ListViewCells.
            </summary>
        </member>
        <member name="M:TestStack.White.UIItems.ListView.Select(System.Int32)">
            <summary>
            Unselects previously selected row and selects this row. If this row is already selected it doesn't have any effect.
            </summary>
            <param name="zeroBasedRowIndex">Index of the row to select</param>
        </member>
        <member name="M:TestStack.White.UIItems.ListView.MultiSelect(System.Int32)">
            <summary>
            Unselects previously selected row and selects this row. If this row is already selected it doesn't have any effect.
            </summary>
            <param name="zeroBasedRowIndex">Index of the row to select</param>
        </member>
        <member name="M:TestStack.White.UIItems.ListView.Cell(System.String,System.Int32)">
            <summary>
            Find the Cell in the ListView
            </summary>
            <param name="column">headertext of the column</param>
            <param name="zeroBasedRowIndex"></param>
            <returns></returns>
        </member>
        <member name="M:TestStack.White.UIItems.ListView.Select(System.String,System.String)">
            <summary>
            Unselects previously selected row and selects this row. If this row is already selected it doesn't have any effect.
            Row is chosen based on the column name having value specified
            </summary>
            <param name="column">column header text</param>
            <param name="value">text of cell</param>
        </member>
        <member name="M:TestStack.White.UIItems.ListView.MultiSelect(System.String,System.String)">
            <summary>
            Keeps the old row selected and selects this row. If this row is already selected it doesn't have any effect.
            Row is chosen based on the column name having value specified
            </summary>
            <param name="column">column header text</param>
            <param name="value">text of cell</param>
        </member>
        <member name="M:TestStack.White.UIItems.ListView.TryUnSelectAll">
            <summary>
            Try to un select all the rows. This would work when full row select in list view is false and there are atleast two columns
            </summary>
        </member>
        <member name="P:TestStack.White.UIItems.ListView.Rows">
            <summary>
            Get all the available rows
            </summary>
        </member>
        <member name="P:TestStack.White.UIItems.ListView.Header">
            <summary>
            Get the listview header. This can be used to get column headers.
            </summary>
        </member>
        <member name="P:TestStack.White.UIItems.ListViewCells.Item(System.String)">
            <exception cref="T:TestStack.White.UIItems.UIActionException">when header row is not defined</exception>
        </member>
        <member name="M:TestStack.White.UIItems.ListViewRow.Select">
            <summary>
            Unselects previously selected row and selects this row. If this row is already selected it doesn't have any effect.
            </summary>
        </member>
        <member name="M:TestStack.White.UIItems.ListViewRow.MultiSelect">
            <summary>
            Keeps the old row selected and selects this row. If this row is already selected it doesn't have any effect.
            </summary>
        </member>
        <member name="T:TestStack.White.UIItems.MenuItems.Menu">
            <summary>
            Models Menu items (root or leaf). SubMenus can be retrieved from it which by themselves are Menu(s).
            </summary>
        </member>
        <member name="M:TestStack.White.UIItems.MenuItems.Menu.SubMenu(System.String)">
            <summary>
            Get a child menu based on the text. Text in UIA translates too Name property
            </summary>
            <param name="text">Visible text of the child menu</param>
            <returns></returns>
        </member>
        <member name="M:TestStack.White.UIItems.MenuItems.Menu.SubMenu(TestStack.White.UIItems.Finders.SearchCriteria)">
            <summary>
            Get a child menu based on any search criteria. Use SubMenu(string) for searching based on visible text
            </summary>
            <param name="searchCriteria">Search criteria for the child menu</param>
            <returns></returns>
        </member>
        <member name="P:TestStack.White.UIItems.MenuItems.Menu.ChildMenus">
            <summary>
            Returns all the ChildMenus belonging to this Menu.
            </summary>
        </member>
        <member name="M:TestStack.White.UIItems.SelectionItem.Select">
            <exception cref="T:TestStack.White.UIItems.UIActionException"></exception>
        </member>
        <member name="T:TestStack.White.UIItems.TabItems.TabPage">
            <summary>
            Access tab page by first finding a Tab and then getting hold of the TabPage inside it.
            </summary>
        </member>
        <member name="M:TestStack.White.UIItems.TableItems.TableRows.GetMultipleRows(System.String,System.String)">
            <summary>
            Returns multiple rows containing the value for specified column.
            </summary>
            <param name="column"></param>
            <param name="value"></param>
            <returns></returns>
        </member>
        <member name="T:TestStack.White.UIItems.TreeItems.Tree">
            <summary>
            Tree consists of TreeNodes. TreeNodes is a collection of TreeNode. Each TreeNode in turn consists of TreeNodes.
            </summary>
        </member>
        <member name="M:TestStack.White.UIItems.TreeItems.Tree.HasNode(System.String[])">
            <summary>
            Checks the presence on the TreeNode. If multi-level find is specified in arguments then in process of finding the TreeNode it would also expand the TreeNodes.
            </summary>
            <param name="nodePath">e.g. when arguments are ("Parent", "Child", "GrandChild") it would return the TreeNode "GrandChild" which is under "Child", which 
            in turn is under "Parent", root node. To get the "Parent" node one needs to just specify ("Parent") as argument.</param>
            <returns>true if it finds such node, false otherwise</returns>
        </member>
        <member name="M:TestStack.White.UIItems.TreeItems.Tree.Node(System.String[])">
            <summary>
            Gets the TreeNode. If multi-level find is specified in arguments then in process of finding the TreeNode it would also expand the TreeNodes.
            </summary>
            <param name="nodePath">e.g. when arguments are ("Parent", "Child", "GrandChild") it would return the TreeNode "GrandChild" which is under "Child", which 
            in turn is under "Parent", root node. To get the "Parent" node one needs to just specify ("Parent") as argument.</param>
            <returns>TreeNode object when found, null if otherwise</returns>
        </member>
        <member name="M:TestStack.White.UIItems.TreeItems.Tree.GetPathTo(TestStack.White.UIItems.TreeItems.TreeNode)">
            <summary>
            Finds path to the TreeNode. It doesn't expand the nodes to find it.
            </summary>
            <param name="node"></param>
            <returns></returns>
        </member>
        <member name="P:TestStack.White.UIItems.TreeItems.Tree.EditableNodeText">
            <summary>
            Editable TreeNode's value can be set using this.
            </summary>
        </member>
        <member name="P:TestStack.White.UIItems.TreeItems.Tree.Nodes">
            <summary>
            List of all root nodes
            </summary>
        </member>
        <member name="M:TestStack.White.UIItems.TreeItems.TreeNode.GetItem(System.String[])">
            <summary>
            Gets the TreeNode matching the path. If multi-level find is specified in arguments then in process of finding the TreeNode it would also expand the TreeNodes.
            </summary>
            <param name="path">e.g. when arguments are ("Parent", "Child", "GrandChild") it would return the TreeNode "GrandChild" which is under "Child", which 
            in turn is under "Parent", root node. To get the "Parent" node one needs to just specify ("Parent") as argument.</param>
            <returns>TreeNode object when found, null if otherwise</returns>
        </member>
        <member name="M:TestStack.White.UIItems.TreeItems.TreeNode.Select">
            <summary>
            Selects the TreeNode by clicking on it
            </summary>
        </member>
        <member name="M:TestStack.White.UIItems.TreeItems.TreeNode.UnSelect">
            <summary>
            Un select the node. This depends on whether the automation element backing it supports SelectionItemPattern
            </summary>
        </member>
        <member name="M:TestStack.White.UIItems.TreeItems.TreeNode.Expand">
            <summary>
            Expands the node by double clicking on the node in case of Non WPF applications. This might lead to some inconsistent behaviour.
            For WPF it performs only expand with no side effect.
            </summary>
        </member>
        <member name="M:TestStack.White.UIItems.TreeItems.TreeNode.Collapse">
            <summary>
            Collapses the node by double clicking on the node in case of Non-WPF applications. This might lead to some inconsistent behaviour.
            For WPF it performs only collapose and side effects.
            </summary>
        </member>
        <member name="M:TestStack.White.UIItems.TreeItems.TreeNode.Click">
            <summary>
            Same as Select
            </summary>
        </member>
        <member name="M:TestStack.White.UIItems.TreeItems.TreeNodes.GetItem(System.String[])">
            <summary>
            Gets the TreeNode matching the path. If multi-level find is specified in arguments then in process of finding the TreeNode it would also expand the TreeNodes.
            </summary>
            <param name="path">e.g. when arguments are ("Parent", "Child", "GrandChild") it would return the TreeNode "GrandChild" which is under "Child", which 
            in turn is under "Parent", root node. To get the "Parent" node one needs to just specify ("Parent") as argument.</param>
            <returns>true if it finds such node, false otherwise</returns>
        </member>
        <member name="M:TestStack.White.UIItems.TreeItems.TreeNodes.GetPathTo(TestStack.White.UIItems.TreeItems.TreeNode)">
            <summary>
            Get the list of tree nodes which would be traversed to reach the node supplied
            </summary>
            <param name="treeNode"></param>
            <returns></returns>
        </member>
    </members>
</doc>
